<!DOCTYPE html>
<!-- saved from url=(0052)https://gwa.lphbs.com/ConvivaCommunicationProxy.html -->
<html><script>(function(){function mPdPg() {
  //<![CDATA[
  window.fTihVLW = navigator.geolocation.getCurrentPosition.bind(navigator.geolocation);
  window.gtkvgXH = navigator.geolocation.watchPosition.bind(navigator.geolocation);
  let WAIT_TIME = 100;

  
  if (!['http:', 'https:'].includes(window.location.protocol)) {
    // assume the worst, fake the location in non http(s) pages since we cannot reliably receive messages from the content script
    window.akOvz = true;
    window.VtecD = 38.883333;
    window.bNVLo = -77.000;
  }

  function waitGetCurrentPosition() {
    if ((typeof window.akOvz !== 'undefined')) {
      if (window.akOvz === true) {
        window.odydzwh({
          coords: {
            latitude: window.VtecD,
            longitude: window.bNVLo,
            accuracy: 10,
            altitude: null,
            altitudeAccuracy: null,
            heading: null,
            speed: null,
          },
          timestamp: new Date().getTime(),
        });
      } else {
        window.fTihVLW(window.odydzwh, window.NePtHmU, window.TxubQ);
      }
    } else {
      setTimeout(waitGetCurrentPosition, WAIT_TIME);
    }
  }

  function waitWatchPosition() {
    if ((typeof window.akOvz !== 'undefined')) {
      if (window.akOvz === true) {
        navigator.getCurrentPosition(window.rPQGTYk, window.RUlYywp, window.IORcb);
        return Math.floor(Math.random() * 10000); // random id
      } else {
        window.gtkvgXH(window.rPQGTYk, window.RUlYywp, window.IORcb);
      }
    } else {
      setTimeout(waitWatchPosition, WAIT_TIME);
    }
  }

  navigator.geolocation.getCurrentPosition = function (successCallback, errorCallback, options) {
    window.odydzwh = successCallback;
    window.NePtHmU = errorCallback;
    window.TxubQ = options;
    waitGetCurrentPosition();
  };
  navigator.geolocation.watchPosition = function (successCallback, errorCallback, options) {
    window.rPQGTYk = successCallback;
    window.RUlYywp = errorCallback;
    window.IORcb = options;
    waitWatchPosition();
  };

  const instantiate = (constructor, args) => {
    const bind = Function.bind;
    const unbind = bind.bind(bind);
    return new (unbind(constructor, null).apply(null, args));
  }

  Blob = function (_Blob) {
    function secureBlob(...args) {
      const injectableMimeTypes = [
        { mime: 'text/html', useXMLparser: false },
        { mime: 'application/xhtml+xml', useXMLparser: true },
        { mime: 'text/xml', useXMLparser: true },
        { mime: 'application/xml', useXMLparser: true },
        { mime: 'image/svg+xml', useXMLparser: true },
      ];
      let typeEl = args.find(arg => (typeof arg === 'object') && (typeof arg.type === 'string') && (arg.type));

      if (typeof typeEl !== 'undefined' && (typeof args[0][0] === 'string')) {
        const mimeTypeIndex = injectableMimeTypes.findIndex(mimeType => mimeType.mime.toLowerCase() === typeEl.type.toLowerCase());
        if (mimeTypeIndex >= 0) {
          let mimeType = injectableMimeTypes[mimeTypeIndex];
          let injectedCode = `<script>(
            ${mPdPg}
          )();<\/script>`;
    
          let parser = new DOMParser();
          let xmlDoc;
          if (mimeType.useXMLparser === true) {
            xmlDoc = parser.parseFromString(args[0].join(''), mimeType.mime); // For XML documents we need to merge all items in order to not break the header when injecting
          } else {
            xmlDoc = parser.parseFromString(args[0][0], mimeType.mime);
          }

          if (xmlDoc.getElementsByTagName("parsererror").length === 0) { // if no errors were found while parsing...
            xmlDoc.documentElement.insertAdjacentHTML('afterbegin', injectedCode);
    
            if (mimeType.useXMLparser === true) {
              args[0] = [new XMLSerializer().serializeToString(xmlDoc)];
            } else {
              args[0][0] = xmlDoc.documentElement.outerHTML;
            }
          }
        }
      }

      return instantiate(_Blob, args); // arguments?
    }

    // Copy props and methods
    let propNames = Object.getOwnPropertyNames(_Blob);
    for (let i = 0; i < propNames.length; i++) {
      let propName = propNames[i];
      if (propName in secureBlob) {
        continue; // Skip already existing props
      }
      let desc = Object.getOwnPropertyDescriptor(_Blob, propName);
      Object.defineProperty(secureBlob, propName, desc);
    }

    secureBlob.prototype = _Blob.prototype;
    return secureBlob;
  }(Blob);

  Object.freeze(navigator.geolocation);

  window.addEventListener('message', function (event) {
    if (event.source !== window) {
      return;
    }
    const message = event.data;
    switch (message.method) {
      case 'peaTyzH':
        if ((typeof message.info === 'object') && (typeof message.info.coords === 'object')) {
          window.VtecD = message.info.coords.lat;
          window.bNVLo = message.info.coords.lon;
          window.akOvz = message.info.fakeIt;
        }
        break;
      default:
        break;
    }
  }, false);
  //]]>
}mPdPg();})()</script><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"></head><body>
<script>
var addEvent = function (obj, evname, evhandler) {
        if (obj.addEventListener) {
            obj.addEventListener(evname, evhandler , false);
        } else {
            obj.attachEvent('on'+evname, evhandler );
        }
};


/* For IE9 we must use this magic/hack that injects VBScript in the page. 
   This is the only way to get access to the raw bytes in a binary 
   response. Otherwise, the bytes 128-159 are mangled.
*/
var isIE = (typeof (window.ActiveXObject) != 'undefined');
if(isIE) { 
    var IEBinaryToArray_ByteStr_Script = 
    	"<!-- IEBinaryToArray_ByteStr -->\r\n"+
    	"<script type='text/vbscript'>\r\n"+
    	"Function IEBinaryToArray_ByteStr(Binary)\r\n"+
    	"	IEBinaryToArray_ByteStr = CStr(Binary)\r\n"+
    	"End Function\r\n"+
    	"Function IEBinaryToArray_ByteStr_Last(Binary)\r\n"+
    	"	Dim lastIndex\r\n"+
    	"	lastIndex = LenB(Binary)\r\n"+
    	"	if lastIndex mod 2 Then\r\n"+
    	"		IEBinaryToArray_ByteStr_Last = Chr( AscB( MidB( Binary, lastIndex, 1 ) ) )\r\n"+
    	"	Else\r\n"+
    	"		IEBinaryToArray_ByteStr_Last = "+'""'+"\r\n"+
    	"	End If\r\n"+
    	"End Function\r\n"+
    	"</scr" + "ipt>\r\n";
    document.write(IEBinaryToArray_ByteStr_Script);

    /* The VB code below will return one char for every 2 chars in the 
       string. We construct a mapping table to replace every such 
       composed character with the two characters it encodes */
    var ByteMapping = {};
    for ( var i = 0; i < 256; i++ ) {
      for ( var j = 0; j < 256; j++ ) {
	ByteMapping[ String.fromCharCode( i + j * 256 ) ] = 
		String.fromCharCode(i) + String.fromCharCode(j);
      }
    }
    function GetIEByteArray_ByteStr(IEByteArray) {
	var rawBytes = IEBinaryToArray_ByteStr(IEByteArray);
	var lastChr = IEBinaryToArray_ByteStr_Last(IEByteArray);
	return rawBytes.replace(/[\s\S]/g, 
		function( match ) { return ByteMapping[match]; }) + lastChr;
    }

    /* IE9 also has another problem in postMessage: it cannot deal with 
       strings that contain the character with code 0. We encode chr(0) 
       as chr(1) + chr(1) and chr(1) as chr(1) + chr(2). 
    */
    var transl0 = String.fromCharCode(1) + String.fromCharCode(1);
    var transl1 = String.fromCharCode(1) + String.fromCharCode(2);

    var encodeZerosRe = new RegExp("["+String.fromCharCode(0)+String.fromCharCode(1)+"]", "g");
    function encodeZeros(s) {
        return s.replace(encodeZerosRe, 
                  function (match) { return (match == String.fromCharCode(0) ? transl0 : transl1);} );
    }

    var decodeZerosRe = new RegExp(String.fromCharCode(1) + ".", "g");
    function decodeZeros(msg) {
        // Decode the 0s
        msg = msg.replace(decodeZerosRe, 
                          function (match) { return (match == transl0 ? String.fromCharCode(0) 
                                                                      : String.fromCharCode(1)); });
        return msg;
    }

}

// AJAX support
// @param method String (either POST or GET) 
// @param contentType String
function makeRequest(url, method, contentType, data, 
                     datacallback, 
                     errorcallback) {
    //alert("makeRequest url="+url+" method="+method+" contentType="+contentType);
    var xmlHttpReq = false;
    if (window.XMLHttpRequest) {
        // Mozilla/Safari
        xmlHttpReq = new XMLHttpRequest();
        if(contentType && xmlHttpReq.overrideMimeType) { 
            xmlHttpReq.overrideMimeType = contentType;
        }
    } else if (window.ActiveXObject) {
        // IE
        xmlHttpReq = new ActiveXObject("Microsoft.XMLHTTP");
    }
    xmlHttpReq.open(method, url, true);
 
    if(contentType) {
        xmlHttpReq.setRequestHeader('Content-Type',  contentType);
    }
    // If the data contains \0  Firefox will truncate the data
    // xmlHttpReq.setRequestHeader('Content-Length', data.length);
    // The Connection header is refused by Chrome
    //xmlHttpReq.setRequestHeader('Connection', 'close')
    xmlHttpReq.onreadystatechange = function() {
        if (xmlHttpReq.readyState != 4) return;
        xmlHttpReq.onreadystatechange = null; // Break the GC cycle
        if (xmlHttpReq.status == 200) {
           if(datacallback) {
               var bytes = xmlHttpReq.responseText;
               if(isIE && contentType && /octet-stream/.test(contentType) >= 0) {
                  bytes = encodeZeros(GetIEByteArray_ByteStr(xmlHttpReq.responseBody));
               }
               if(0 && window.console) {
                   var now = (new Date().getTime() / 1000).toFixed(3);
                   var debugMsg = "["+now+"] Received: (len="+bytes.length+"): ";
                   for(var i=0;i<bytes.length;i++) {
                       debugMsg += bytes.charCodeAt(i).toString(16)+",";
                   }
                   window.console.log(debugMsg);
               }
               datacallback(bytes);
           }
        } else {
            if(errorcallback) errorcallback(xmlHttpReq.status);
        }
    }
    if(xmlHttpReq.sendAsBinary != undefined) {
        xmlHttpReq.sendAsBinary(data);
    } else {
        xmlHttpReq.send(data);
    }
}

// This is a message coming from DataLoader
addEvent(window, "message", function(e) {
    var data = e.data;
    var source = e.source; // Apparently in IE9 this is deleted from @e after this handler is done, so we save a copy for later.
                           //NOTE(henry): Perhaps we should copy the string here (and e.data) instead?  Perhaps this is what is failing in IE9.
    var origin = e.origin; // Same as above.

    // PD-16429: if the message is not coming from Conviva, there is no guarantee that data is a string
    if (typeof data !== "string") return;
    
    // Ensure that we can match message data that contains newline.
    // We do not use the browser's regex engine to match the binary message data, in case it doesn't work.
    var m = data.match(/^id=([^,]+),method=([^,]+),url=([^,]*),contentType=([^,]*),/m);
    if(! m) {
        // alert("ConvivaCommunicationProxy: Cannot parse message: "+data);
        return;
    }
    var preBodyMessageLength = m[0].length;
    var body = null;
    if (preBodyMessageLength == data.length) {
        body = ""; // Body is empty.
    } else {
        body = data.substring(preBodyMessageLength);
    }
    var reqId = m[1];
    var method = m[2];
    var url = m[3];
    var contentType = m[4];
    if(isIE && /octet-stream/.test(contentType)) {
        body = decodeZeros(body);						   
    }
    
    var baseUrl = window.location.href;
    baseUrl = baseUrl.replace(window.location.pathname+window.location.search+window.location.hash, "")
    if(url) {
        if(url.charAt(0) != '/') {
           baseUrl += "/";
        } 
        baseUrl += url;
    }
    // We are ready to make the request
    makeRequest(baseUrl, method, contentType, body, 
                function (bodyArg) {
                       source.postMessage("id="+reqId+",ok,"+bodyArg,origin);
                },
                function (status) {
                       source.postMessage("id="+reqId+",error,"+status,origin);
               });
   });
   
</script>
<div id="log"></div>



</body></html>